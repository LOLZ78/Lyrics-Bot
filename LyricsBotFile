-- üé∂ FULL LYRICS BOT SCRIPT
repeat task.wait() until game:IsLoaded()

if not getgenv().executedLyricsBot then
    getgenv().executedLyricsBot = true
else
    return
end

-- Services
local httprequest = (syn and syn.request) or http and http.request or http_request or (fluxus and fluxus.request) or request
local HttpService = game:GetService("HttpService")
local ChatEvents = game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents
local Players = game:GetService("Players")

-- Bot state
local state = "ready"
local plr = nil
local lastRequestTime = 0
local cooldown = 30  -- seconds

-- Messaging
local function sendMessage(text)
    ChatEvents.SayMessageRequest:FireServer(text, "All")
end

local intros = {
    "üéµ Let's sing!",
    "üé§ Starting the show!",
    "üé∂ Here comes the melody!",
    "üéß Requested by %s ‚Äî enjoy!"
}

-- Command parsing
local function parseCommand(message)
    local clean = message:lower():gsub('>song ', ''):gsub('"', ''):gsub(' by ', '/')
    return string.match(clean, "(.-)/(.-)$")
end

-- Chat listener
ChatEvents:WaitForChild('OnMessageDoneFiltering').OnClientEvent:Connect(function(msgdata)
    if state == "singing" then return end

    if plr and (msgdata.FromSpeaker == plr or msgdata.FromSpeaker == Players.LocalPlayer.Name) then
        if string.lower(msgdata.Message) == '>stop' then
            state = "ready"
            sendMessage('üõë Stopped singing.')
            return
        end
    end

    if state == "ready" and string.match(msgdata.Message, '>song "?.-" by "?.-"') then
        if os.time() - lastRequestTime < cooldown then
            sendMessage("‚è≥ Please wait before requesting another song.")
            return
        end
        lastRequestTime = os.time()

        state = "loading"
        plr = Players[msgdata.FromSpeaker].Name

        local songName, artist = parseCommand(msgdata.Message)
        if not (songName and artist) then
            sendMessage('‚ùå Invalid format. Use ">song SongName by Artist"')
            state = "ready"
            return
        end

        sendMessage('üîÑ Loading "' .. songName .. '" by ' .. artist .. '...')
        task.wait(2)

        local response
        local success, err = pcall(function()
            response = httprequest({
                Url = "https://lyrist.vercel.app/api/" .. songName:gsub(" ", "%20"):lower() .. "/" .. artist:gsub(" ", "%20"):lower(),
                Method = "GET",
            })
        end)

        if not success or not response or not response.Body then
            sendMessage('‚ö†Ô∏è Error fetching lyrics. Try again later.')
            state = "ready"
            return
        end

        local lyricsData = HttpService:JSONDecode(response.Body)
        if not lyricsData or lyricsData.error == "Lyrics Not found" then
            sendMessage('üîç Lyrics not found.')
            state = "ready"
            return
        end

        sendMessage('‚úÖ Lyrics found! Starting performance...')
        task.wait(2)
        state = "singing"

        sendMessage(string.format(intros[math.random(#intros)], Players[msgdata.FromSpeaker].DisplayName))
        task.wait(2)

        for line in string.gmatch(lyricsData.lyrics, "[^\n]+") do
            if state ~= "singing" then break end
            if line ~= "" and #line < 120 then
                sendMessage('üéôÔ∏è | ' .. line)
                task.wait(4.5)
            end
        end

        task.wait(2)
        state = "ready"
        sendMessage('üèÅ Song ended. You can request another!')
    end
end)

-- üîÅ Periodic help message
task.spawn(function()
    while task.wait(25) do
        if state == "ready" then
            sendMessage('üéµ Type ">song SongName by Artist" and I‚Äôll sing it for you!')
            task.wait(2)
            sendMessage('üìå Example: ">song Yellow by Coldplay"')
        end
    end
end)

-- Initial greeting
sendMessage('üéµ Type ">song SongName by Artist" and I‚Äôll sing it for you!')
task.wait(2)
sendMessage('üìå Example: ">song Yellow by Coldplay"')
